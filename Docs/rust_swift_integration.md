Here's a detailed guide on **porting a Rust function into Swift**, outlining key steps, common pitfalls, and build steps between Rust and Xcode.

---

# **Porting Rust Functions to Swift: A Detailed Guide**

## **Overview**
Porting Rust functions into Swift requires:
1. **Creating an FFI bridge** in Rust using `#[no_mangle]` and `extern "C"` functions.
2. **Generating a C header file** using `cbindgen`.
3. **Building the Rust library** as a static or dynamic library.
4. **Linking the Rust library** in Xcode.
5. **Calling Rust functions** from Swift using `@_silgen_name` or `UnsafePointer`.

---

## **Step 1: Writing the Rust Function**
### **1Ô∏è‚É£ Define the Rust Function with an FFI Interface**
To expose Rust functions to Swift, they **must** be marked as `#[no_mangle]` and use `extern "C"` to ensure proper C linkage.

```rust
use std::ffi::{CStr, CString};
use std::os::raw::c_char;

/// Returns the Git version as a C string for Swift.
#[no_mangle]
pub extern "C" fn get_git_version() -> *const c_char {
    let version = "git version 2.34.0 (libgit2)".to_string();
    CString::new(version).unwrap().into_raw()
}

/// Clones a Git repository.
/// Returns `0` on success and `-1` on failure.
#[no_mangle]
pub extern "C" fn clone_repo(url: *const c_char, path: *const c_char) -> i32 {
    let url = unsafe { CStr::from_ptr(url).to_string_lossy().into_owned() };
    let path = unsafe { CStr::from_ptr(path).to_string_lossy().into_owned() };

    match git2::Repository::clone(&url, &path) {
        Ok(_) => 0,  // Success
        Err(_) => -1, // Failure
    }
}

/// Frees memory for C strings returned to Swift.
#[no_mangle]
pub extern "C" fn free_c_string(ptr: *mut c_char) {
    if ptr.is_null() { return; }
    unsafe { let _ = CString::from_raw(ptr); } // ‚úÖ Properly frees memory
}
```

### **2Ô∏è‚É£ Key Considerations**
- **Memory Management:** Any `CString::new(...).unwrap().into_raw()` returned must have a matching `free_c_string(...)` in Swift.
- **Error Handling:** Rust errors should be converted into integer return values or handled with logging.
- **Data Conversion:** Rust strings need to be converted into C-style strings (`*const c_char`).

---

## **Step 2: Generating a C Header with `cbindgen`**
### **1Ô∏è‚É£ Add a `cbindgen.toml` File**
```toml
language = "C"
header = "// Generated by cbindgen"

include_guard = "HEARTWOOD_BRIDGE_H"
pragma_once = true

[export]
include = ["get_git_version", "clone_repo", "free_c_string"]

[parse]
parse_deps = true
include = ["get_git_version", "clone_repo", "free_c_string"]
```

### **2Ô∏è‚É£ Generate the Header File**
Run this command in your Rust library directory:
```bash
cbindgen --config cbindgen.toml --crate heartwood_ios_bridge --output include/heartwood_bridge.h
```

This generates:
```c
// Generated by cbindgen
#ifndef HEARTWOOD_BRIDGE_H
#define HEARTWOOD_BRIDGE_H

#pragma once

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

const char* get_git_version();
void free_c_string(char* ptr);
int clone_repo(const char* url, const char* path);

#endif // HEARTWOOD_BRIDGE_H
```

---

## Automation

Steps `3.2` and `4.1` below are automated via the `build_ios.sh` found in `RadicleApp/RustCore/ios-bridge/`

Run the following to build:
```
cd RustCore/ios-bridge/
sh build_ios.sh
```

---

## **Step 3: Build the Rust Library**
### **1Ô∏è‚É£ Update `Cargo.toml`**
```toml
[package]
name = "heartwood_ios_bridge"
version = "0.1.0"
edition = "2021"

[lib]
name = "heartwood_ios_bridge"
crate-type = ["staticlib", "cdylib"] # Required for iOS linking

[dependencies]
git2 = { version = "0.19.0", features = ["vendored-libgit2"] }

[build-dependencies]
cc = "1.0"
pkg-config = "0.3"

[dependencies.openssl-sys]
version = "0.9"
features = ["vendored"]
```

### **2Ô∏è‚É£ Build for iOS Targets**
```bash
cargo build --release --target aarch64-apple-ios
cargo build --release --target aarch64-apple-ios-sim
```

### **3Ô∏è‚É£ Generate the `.a` (Static Library)**
Find the built static library:
```bash
ls target/aarch64-apple-ios/release/
# Should see `libheartwood_ios_bridge.a`
```

---

## **Step 4: Link Rust Library in Xcode**
### **1Ô∏è‚É£ Create an XCFramework**
Run the following commands:
```bash
lipo -create -output build/ios/libheartwood_ios_bridge_sim.a \
    target/x86_64-apple-ios/release/libheartwood_ios_bridge.a \
    target/aarch64-apple-ios-sim/release/libheartwood_ios_bridge.a

xcodebuild -create-xcframework \
    -library target/aarch64-apple-ios/release/libheartwood_ios_bridge.a \
    -headers include/ \
    -library build/ios/libheartwood_ios_bridge_sim.a \
    -headers include/ \
    -output build/ios/Heartwood.xcframework
```

### **2Ô∏è‚É£ Add the XCFramework to Xcode**
1. Open **Xcode** ‚Üí **Project Settings**.
2. Go to **Build Phases** ‚Üí **Link Binary with Libraries**.
3. Add **`Heartwood.xcframework`**.
4. Ensure **Header Search Paths** includes `include/`.

---

## **Step 5: Call Rust Functions in Swift**
### **1Ô∏è‚É£ Declare Rust Functions in Swift**
```swift
@_silgen_name("get_git_version")
func get_git_version() -> UnsafePointer<CChar>?

@_silgen_name("clone_repo")
func clone_repo(_ url: UnsafePointer<CChar>, _ path: UnsafePointer<CChar>) -> Int32

@_silgen_name("free_c_string")
func free_c_string(_ ptr: UnsafeMutablePointer<CChar>)
```

### **2Ô∏è‚É£ Wrap Rust Calls in a Swift Class**
```swift
import Foundation

class GitWrapper {
    func getGitVersion() -> String {
        guard let cString = get_git_version() else { return "Unknown version" }
        let version = String(cString: cString)
        free_c_string(UnsafeMutablePointer(mutating: cString)) // ‚úÖ Free memory
        return version
    }

    func cloneRepository(url: String, path: String) -> Bool {
        let urlCString = url.cString(using: .utf8)!
        let pathCString = path.cString(using: .utf8)!
        return clone_repo(urlCString, pathCString) == 0
    }
}
```

### **3Ô∏è‚É£ Use in `ContentView.swift`**
```swift
struct ContentView: View {
    @StateObject private var gitViewModel = GitViewModel()
    
    var body: some View {
        VStack {
            Text("Git Version: \(gitViewModel.gitVersion)")

            Button("Fetch Git Version") {
                gitViewModel.fetchGitVersion()
            }
            
            Button("Clone Repository") {
                let success = gitViewModel.cloneRepository(
                    url: "https://github.com/bordumb/wsbtrading",
                    path: "/tmp/repo"
                )
                print(success ? "Clone successful!" : "Clone failed.")
            }
        }
    }
}
```

---

## **Common Issues & Fixes**
### **1Ô∏è‚É£ Function Not Found in Swift**
- Ensure Rust functions have `#[no_mangle]` and `extern "C"`.
- Run `nm` on the Rust `.a` library to verify symbols:
  ```bash
  nm target/aarch64-apple-ios/release/libheartwood_ios_bridge.a | grep get_git_version
  ```

### **2Ô∏è‚É£ "Function type mismatch" in Swift**
- Ensure `free_c_string` is declared as `UnsafeMutablePointer<CChar>?` in Swift.

### **3Ô∏è‚É£ Xcode Linking Errors**
- Make sure `Heartwood.xcframework` is properly added under **Linked Frameworks**.

---

## **Conclusion**
‚úÖ **Rust provides performance and safety**, while Swift enables a smooth UI.  
‚úÖ **FFI bridges** let Swift call Rust safely.  
‚úÖ **Careful memory management** prevents leaks.  

üöÄ **Now you can port Rust functions into Swift and build cross-platform apps efficiently!** üöÄ
